#include <iostream>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <list>
#include "estado.cpp"

using namespace std;

class Camino {
public:
  Estado ult_nodo;
  char* acciones;
  int costo;
  Camino(Estado ult_nodo, char* acciones, int costo);
  void print();
  list<Camino> sucesores();
  void calc_sucesores(char *accion_ejecutada,list<Camino> *sucesores);
};

Camino::Camino(Estado info_nodo, char* info_acciones, int info_costo){
  acciones = info_acciones;
  ult_nodo = info_nodo;
  costo=info_costo;
}

void Camino::print(){
  int i;
  char *acciones_aux = acciones;
  int j=strlen(acciones);
  for(i=0;i<j;i++){
    if (*acciones=='u') cout<<" UP ";
    else if (*acciones=='d') cout<<" DOWN ";
    else if (*acciones=='l') cout<<" LEFT ";
    else if (*acciones=='r') cout<<" RIGHT ";
    acciones++;
  }
  acciones = acciones_aux;
  cout<<'\n';
}

list<Camino> Camino::sucesores(){

  list<Camino> sucesores;

  if (ult_nodo.pos_cero >= '0' && ult_nodo.pos_cero <= '5'){
    calc_sucesores((char *)"d",&sucesores);
  }
  if (ult_nodo.pos_cero >= '3' && ult_nodo.pos_cero <= '8') {    
    calc_sucesores((char *)"u",&sucesores);
  }
  if (ult_nodo.pos_cero != '2' && ult_nodo.pos_cero != '5' && ult_nodo.pos_cero != '8'){
    calc_sucesores((char *)"r",&sucesores);
  } 
  if (ult_nodo.pos_cero != '0' && ult_nodo.pos_cero != '3' && ult_nodo.pos_cero != '6'){
    calc_sucesores((char *)"l",&sucesores);
  }

  return sucesores;

}

void Camino::calc_sucesores(char *accion_ejecutada,list<Camino> *sucesores) {
  //Se crea un nuevo estado igual al estado actual
  Estado estado_suc = ult_nodo.clon();
  short int num1,num2;
  num1=(int)ult_nodo.pos_cero-48;

  if (strcmp(accion_ejecutada,"u") == 0) {
    num2 = num1 - 3;
  } else if (strcmp(accion_ejecutada,"d") == 0) {
    num2 = num1 + 3;
  } else if (strcmp(accion_ejecutada,"r") == 0) {
    num2 = num1 + 1;
  } else if (strcmp(accion_ejecutada,"l") == 0) {
    num2 = num1 -1;
  }
  
  //Se intercambian las posiciones de 2 numeros en el nuevo estado
  estado_suc.swap(num1,num2);
  
  //Si no, hacer nuevo camino con movimiento UP,DOWN,LEFT o RIGTH.
  char *nueva_accion = (char *)malloc(128*sizeof(char));
  strcpy(nueva_accion,acciones);
  strcat(nueva_accion,accion_ejecutada);
  Camino camino_nuevo(estado_suc,nueva_accion,costo+1);
  (*sucesores).push_back(camino_nuevo);
  
}

