#include <iostream>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h> 
#include "camino.cpp"
#include <list>

using namespace std;

void almacenar(list<Camino> cam_hallados[32],Camino camino) {
  short int suma = camino.ult_nodo.suma;
  cam_hallados[suma].push_back(camino);
}

bool fue_visitado(list<Camino> cam_hallados[32],Camino camino) {
  list<Camino>::iterator cam;
  short int suma = camino.ult_nodo.suma;
  for (cam = cam_hallados[suma].begin();cam != cam_hallados[suma].end();cam++) {
    if ((*cam).ult_nodo.es_igual(camino.ult_nodo)) return 1;
  }
  return 0;
}

void BFS(list<Camino> colaBFS) {

  list<Camino> cam_hallados[32];
  list<Camino> sucesores;
  list<Camino>::iterator cam;
  int flag = 0;
  while (!colaBFS.empty()) {
    if (colaBFS.front().ult_nodo.es_objetivo()) {
      cout<<"\nSolucion hallada...\n\n";
      cout<<"Secuencia de Acciones: ";
      colaBFS.front().print();
      cout<<"\n";
      flag = 1;
      break;
    } else {
      sucesores = colaBFS.front().sucesores();
      colaBFS.pop_front();
      for (cam = sucesores.begin();cam != sucesores.end();cam++) {
	if (fue_visitado(cam_hallados,*cam)) 
	  continue;
	else {
	  colaBFS.push_back(*cam);
	  almacenar(cam_hallados,*cam);
	}
      }
    }
  }
  if (flag == 0) cout<<"La instancia dada no tiene solucion.\n";
}

<<<<<<< .mine
=======
void UCS(list<Camino> listaUCS){

>>>>>>> .r19
  
}


void DFS(list<Camino> pilaDFS) {

  list<Camino> cam_hallados[32];
  list<Camino> sucesores;
  list<Camino>::iterator cam;
  int flag = 0;
  while (!pilaDFS.empty()) {
    if (pilaDFS.front().ult_nodo.es_objetivo()) {
      cout<<"\nSolucion hallada...\n\n";
      cout<<"Secuencia de Acciones: ";
      pilaDFS.front().print();
      cout<<"\n";
      flag = 1;
      break;
    } else {
      sucesores = pilaDFS.front().sucesores();
      pilaDFS.pop_front();
      for (cam = sucesores.begin();cam != sucesores.end();cam++) {
	if (fue_visitado(cam_hallados,*cam)) 
	  continue;
	else {
	  pilaDFS.push_front(*cam);
	  almacenar(cam_hallados,*cam);
	}
      }
    }
  }
  if (flag == 0) cout<<"La instancia dada no tiene solucion.\n";
}

int main(int argc, char ** argv) {

/**************** Instanciar el estado y camino inicial con argumentos*********************************/

  char *info_nodo;
  if (argc!=11) {
    cout<<"ERROR... Use: ./8puzzle <nombre_algoritmo> <numeros [0,8] separados por ' '(espacios)>\n";
    exit(0);
  }else {
    info_nodo=argv[2];
    int i;
    for(i=3;i<11;i++) {
      if (strcmp(argv[i],"1")&&strcmp(argv[i],"2")&&strcmp(argv[i],"3")&&
	  strcmp(argv[i],"4")&&strcmp(argv[i],"5")&&strcmp(argv[i],"6")&&
	  strcmp(argv[i],"7")&&strcmp(argv[i],"8")&&strcmp(argv[i],"0"))
	{
	  cout<<"ERROR... Use: ./8puzzle <nombre_algoritmo> <numeros [0,8] separados por ' '(espacios)>\n";
	  exit(0);
	}
      else strcat(info_nodo,argv[i]);
    }
  }

  Estado nodo_inicial(info_nodo);
  char acciones_hechas[] = "";
  Camino camino(nodo_inicial,acciones_hechas,1);
  //clock_t t_ini, t_fin;
  struct timeval t;
  double t_ini,t_fin;
  double secs;

/*************************************************************************************************************/
/***************Aqui comienzan las corridas de los algoritmos ***********************************************/

  if (strcmp(argv[1],"BFS") == 0 || strcmp(argv[1],"bfs") == 0) {
    
    list<Camino> colaBFS;
    cout<<"Hacemos BFS\n";
/***********/
    gettimeofday (&t, NULL);
    t_ini = (double)t.tv_sec + (t.tv_usec/1000000.0); 
//    t_ini = clock();
    colaBFS.push_back(camino);
    BFS(colaBFS);
    
  } else if (strcmp(argv[1],"UCS") == 0 || strcmp(argv[1],"ucs") == 0) {

    cout<<"Hacemos UCS\n";

  } else if (strcmp(argv[1],"DFS") == 0 || strcmp(argv[1],"dfs") == 0) {
    
    list<Camino> pilaDFS;
    cout<<"Hacemos DFS\n";
    t_ini = clock();
    pilaDFS.push_front(camino);
    DFS(pilaDFS);

  } else if (strcmp(argv[1],"IDS") == 0 || strcmp(argv[1],"ids") == 0) {

    cout<<"Hacemos IDS\n";

  } else cout<<"ERROR... Inserte un Algoritmo valido\n";

  gettimeofday (&t, NULL);
  t_fin = (double)t.tv_sec + (t.tv_usec/1000000.0); 
  //t_fin = clock();
  //secs = (double)(t_fin - t_ini) / CLOCKS_PER_SEC;
  secs = t_fin - t_ini;
  int min = ((int)secs / 60);
  double seg = secs - (min*60); 
  printf("Tiempo de ejecucion: %d minuto(s), %f segundo(s)\n", min, seg);
  //printf("Tiempo de ejecucion: %d minuto(s), %d segundo(s)\n", ((int)secs / 60), (int)secs % 60);
  cout<<"\n";

  return 0;

}

